-- LinoriaLib UI Script for Roblox with ESP Integration
-- Main, ESP, and Settings tabs

local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TeleportService = game:GetService("TeleportService")
local LocalPlayer = Players.LocalPlayer

-- Create the main window
local Window = Library:CreateWindow({
    Title = 'Roblox Script Hub',
    Center = true,
    AutoShow = true,
})

-- Create tabs
local Tabs = {
    Main = Window:AddTab('Main'),
    ESP = Window:AddTab('ESP'),
    Settings = Window:AddTab('Settings'),
}

--[[
    ESP MODULE - Exunys ESP (Boxes, HP, Names only)
    EXACT SOURCE CODE EMBEDDED - NO LOADSTRING
    Source: https://raw.githubusercontent.com/Exunys/Exunys-ESP/refs/heads/main/src/ESP.lua
]]
local ESPModule
do
    --// Caching
    local game = game
    local assert, loadstring, select, next, type, typeof, pcall, xpcall, setmetatable, getmetatable, tick, warn = assert, loadstring, select, next, type, typeof, pcall, xpcall, setmetatable, getmetatable, tick, warn
    local mathfloor, mathabs, mathcos, mathsin, mathrad, mathdeg, mathmin, mathmax, mathclamp, mathrandom = math.floor, math.abs, math.cos, math.sin, math.rad, math.deg, math.min, math.max, math.clamp, math.random
    local stringformat, stringfind, stringchar = string.format, string.find, string.char
    local unpack = table.unpack
    local wait, spawn = task.wait, task.spawn
    local getgenv, getrawmetatable, getupvalue, gethiddenproperty, cloneref, clonefunction = getgenv, getrawmetatable, debug.getupvalue, gethiddenproperty, cloneref or function(...)
        return ...
    end, clonefunction or function(...)
        return ...
    end

    --// Custom Drawing Library
    if not Drawing or not Drawing.new or not Drawing.Fonts then
        loadstring(game.HttpGet(game, "https://pastebin.com/raw/huyiRsK0"))()
        repeat
            wait(0)
        until Drawing and Drawing.new and type(Drawing.new) == "function" and Drawing.Fonts and type(Drawing.Fonts) == "table"
    end

    local ConfigLibrary = loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/Exunys/Config-Library/main/Main.lua"))()

    local Vector2new, Vector3zero, CFramenew = Vector2.new, Vector3.zero, CFrame.new
    local Drawingnew, DrawingFonts = Drawing.new, Drawing.Fonts
    local Color3fromRGB, Color3fromHSV = Color3.fromRGB, Color3.fromHSV

    local GameMetatable = getrawmetatable and getrawmetatable(game) or {
        __index = function(self, Index)
            return self[Index]
        end,
        __newindex = function(self, Index, Value)
            self[Index] = Value
        end
    }

    local __index = GameMetatable.__index
    local __newindex = GameMetatable.__newindex

    local getrenderproperty, setrenderproperty, cleardrawcache = getrenderproperty or __index, setrenderproperty or __newindex, cleardrawcache

    local _get, _set = function(self, Index)
        return self[Index]
    end, function(self, Index, Value)
        self[Index] = Value
    end

    if identifyexecutor() == "Solara" then
        local DrawQuad = loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/Exunys/Custom-Quad-Render-Object/main/Main.lua"))()
        local _Drawingnew = clonefunction(Drawing.new)
        Drawingnew = function(...)
            return ({...})[1] == "Quad" and DrawQuad(...) or _Drawingnew(...)
        end
    end

    local _GetService = __index(game, "GetService")
    local FindFirstChild, WaitForChild = __index(game, "FindFirstChild"), __index(game, "WaitForChild")
    local IsA = __index(game, "IsA")

    local GetService = function(Service)
        return cloneref(_GetService(game, Service))
    end

    local WorkspaceESP = GetService("Workspace")
    local PlayersESP = GetService("Players")
    local RunServiceESP = GetService("RunService")
    local UserInputServiceESP = GetService("UserInputService")

    local CurrentCamera = __index(WorkspaceESP, "CurrentCamera")
    local LocalPlayerESP = __index(PlayersESP, "LocalPlayer")

    local FindFirstChildOfClass = function(self, ...)
        return typeof(self) == "Instance" and self.FindFirstChildOfClass(self, ...)
    end

    local Cache = {
        WorldToViewportPoint = __index(CurrentCamera, "WorldToViewportPoint"),
        GetPlayers = __index(PlayersESP, "GetPlayers"),
        GetPlayerFromCharacter = __index(PlayersESP, "GetPlayerFromCharacter"),
        GetMouseLocation = __index(UserInputServiceESP, "GetMouseLocation")
    }

    local WorldToViewportPoint = function(...)
        return Cache.WorldToViewportPoint(CurrentCamera, ...)
    end

    local GetPlayers = function()
        return Cache.GetPlayers(PlayersESP)
    end

    local GetPlayerFromCharacter = function(...)
        return Cache.GetPlayerFromCharacter(PlayersESP, ...)
    end

    local GetMouseLocation = function()
        return Cache.GetMouseLocation(UserInputServiceESP)
    end

    local IsDescendantOf = function(self, ...)
        return typeof(self) == "Instance" and self.IsDescendantOf(self, ...)
    end

    local Connect, Disconnect = __index(game, "DescendantAdded").Connect

    local Inf, Nan, LoadedESP, CrosshairParts = 1 / 0, 0 / 0, false, {
        OutlineLeftLine = Drawingnew("Line"),
        OutlineRightLine = Drawingnew("Line"),
        OutlineTopLine = Drawingnew("Line"),
        OutlineBottomLine = Drawingnew("Line"),
        OutlineCenterDot = Drawingnew("Circle"),
        LeftLine = Drawingnew("Line"),
        RightLine = Drawingnew("Line"),
        TopLine = Drawingnew("Line"),
        BottomLine = Drawingnew("Line"),
        CenterDot = Drawingnew("Circle")
    }

    if ExunysDeveloperESP and ExunysDeveloperESP.Exit then
        ExunysDeveloperESP:Exit()
    end

    getgenv().ExunysDeveloperESP = {
        DeveloperSettings = {
            Path = "Exunys Developer/Exunys ESP/Configuration.cfg",
            UnwrapOnCharacterAbsence = false,
            UpdateMode = "RenderStepped",
            TeamCheckOption = "TeamColor",
            RainbowSpeed = 1,
            WidthBoundary = 1.5
        },
        Settings = {
            Enabled = true,
            PartsOnly = false,
            TeamCheck = false,
            AliveCheck = true,
            LoadConfigOnLaunch = false,
            EnableTeamColors = false,
            TeamColor = Color3fromRGB(170, 170, 255)
        },
        Properties = {
            ESP = {
                Enabled = true,
                RainbowColor = false,
                RainbowOutlineColor = false,
                Offset = 10,
                Color = Color3fromRGB(255, 255, 255),
                Transparency = 1,
                Size = 14,
                Font = DrawingFonts.Plex,
                OutlineColor = Color3fromRGB(0, 0, 0),
                Outline = true,
                DisplayDistance = false,
                DisplayHealth = false,
                DisplayName = true,
                DisplayDisplayName = true,
                DisplayTool = false
            },
            Tracer = {
                Enabled = false,
                RainbowColor = false,
                RainbowOutlineColor = false,
                Position = 1,
                Transparency = 1,
                Thickness = 1,
                Color = Color3fromRGB(255, 255, 255),
                Outline = true,
                OutlineColor = Color3fromRGB(0, 0, 0)
            },
            HeadDot = {
                Enabled = false,
                RainbowColor = false,
                RainbowOutlineColor = false,
                Color = Color3fromRGB(255, 255, 255),
                Transparency = 1,
                Thickness = 1,
                NumSides = 30,
                Filled = false,
                OutlineColor = Color3fromRGB(0, 0, 0),
                Outline = true
            },
            Box = {
                Enabled = true,
                RainbowColor = false,
                RainbowOutlineColor = false,
                Color = Color3fromRGB(255, 255, 255),
                Transparency = 1,
                Thickness = 1,
                Filled = false,
                OutlineColor = Color3fromRGB(0, 0, 0),
                Outline = true
            },
            HealthBar = {
                Enabled = true,
                RainbowOutlineColor = false,
                Offset = 4,
                Blue = 100,
                Position = 3,
                Thickness = 1,
                Transparency = 1,
                OutlineColor = Color3fromRGB(0, 0, 0),
                Outline = true
            },
            Chams = {
                Enabled = false,
                RainbowColor = false,
                Color = Color3fromRGB(255, 255, 255),
                Transparency = 0.2,
                Thickness = 1,
                Filled = false
            },
            Crosshair = {
                Enabled = false,
                RainbowColor = false,
                RainbowOutlineColor = false,
                TStyled = false,
                Position = 1,
                Size = 12,
                GapSize = 6,
                Rotation = 0,
                Rotate = false,
                RotateClockwise = true,
                RotationSpeed = 5,
                PulseGap = false,
                PulsingStep = 10,
                PulsingSpeed = 5,
                PulsingBounds = {4, 8},
                Color = Color3fromRGB(0, 255, 0),
                Thickness = 1,
                Transparency = 1,
                OutlineColor = Color3fromRGB(0, 0, 0),
                Outline = true,
                CenterDot = {
                    Enabled = true,
                    RainbowColor = false,
                    RainbowOutlineColor = false,
                    Radius = 2,
                    Color = Color3fromRGB(0, 255, 0),
                    Transparency = 1,
                    Thickness = 1,
                    NumSides = 60,
                    Filled = false,
                    OutlineColor = Color3fromRGB(0, 0, 0),
                    Outline = true
                }
            }
        },
        UtilityAssets = {
            WrappedObjects = {},
            ServiceConnections = {}
        }
    }

    local Environment = getgenv().ExunysDeveloperESP

    local function Recursive(Table, Callback)
        for Index, Value in next, Table do
            Callback(Index, Value)
            if type(Value) == "table" then
                Recursive(Value, Callback)
            end
        end
    end

    local CoreFunctions = {
        ConvertVector = function(Vector)
            return Vector2new(Vector.X, Vector.Y)
        end,
        GetColorFromHealth = function(Health, MaxHealth, Blue)
            return Color3fromRGB(255 - mathfloor(Health / MaxHealth * 255), mathfloor(Health / MaxHealth * 255), Blue or 0)
        end,
        GetRainbowColor = function()
            local RainbowSpeed = Environment.DeveloperSettings.RainbowSpeed
            return Color3fromHSV(tick() % RainbowSpeed / RainbowSpeed, 1, 1)
        end,
        GetLocalCharacterPosition = function()
            local LocalCharacter = __index(LocalPlayerESP, "Character")
            local LocalPlayerCheckPart = LocalCharacter and (__index(LocalCharacter, "PrimaryPart") or FindFirstChild(LocalCharacter, "Head"))
            return LocalPlayerCheckPart and __index(LocalPlayerCheckPart, "Position") or __index(CurrentCamera, "CFrame").Position
        end,
        GenerateHash = function(Bits)
            local Result = ""
            for _ = 1, Bits do
                Result ..= ("EXUNYS_ESP")[mathrandom(1, 2) == 1 and "upper" or "lower"](stringchar(mathrandom(97, 122)))
            end
            return Result
        end,
        CalculateParameters = function(Object)
            Object = type(Object) == "table" and Object.Object or Object
            local DeveloperSettings = Environment.DeveloperSettings
            local WidthBoundary = DeveloperSettings.WidthBoundary
            local IsAPlayer = IsA(Object, "Player")
            local Part = IsAPlayer and (FindFirstChild(PlayersESP, __index(Object, "Name")) and __index(Object, "Character"))
            Part = IsAPlayer and Part and (__index(Part, "PrimaryPart") or FindFirstChild(Part, "HumanoidRootPart")) or Object
            if not Part or IsA(Part, "Player") then
                return nil, nil, false
            end
            local PartCFrame, PartPosition, PartUpVector = __index(Part, "CFrame"), __index(Part, "Position")
            PartUpVector = PartCFrame.UpVector
            local RigType = FindFirstChild(__index(Part, "Parent"), "Torso") and "R6" or "R15"
            local CameraUpVector = __index(CurrentCamera, "CFrame").UpVector
            local Top, TopOnScreen = WorldToViewportPoint(PartPosition + (PartUpVector * (RigType == "R6" and 0.5 or 1.8)) + CameraUpVector)
            local Bottom, BottomOnScreen = WorldToViewportPoint(PartPosition - (PartUpVector * (RigType == "R6" and 4 or 2.5)) - CameraUpVector)
            local TopX, TopY = Top.X, Top.Y
            local BottomX, BottomY = Bottom.X, Bottom.Y
            local Width = mathmax(mathfloor(mathabs(TopX - BottomX)), 3)
            local Height = mathmax(mathfloor(mathmax(mathabs(BottomY - TopY), Width / 2)), 3)
            local BoxSize = Vector2new(mathfloor(mathmax(Height / (IsAPlayer and WidthBoundary or 1), Width)), Height)
            local BoxPosition = Vector2new(mathfloor(TopX / 2 + BottomX / 2 - BoxSize.X / 2), mathfloor(mathmin(TopY, BottomY)))
            return BoxPosition, BoxSize, (TopOnScreen and BottomOnScreen)
        end,
        GetColor = function(Player, DefaultColor)
            local Settings, TeamCheckOption = Environment.Settings, Environment.DeveloperSettings.TeamCheckOption
            return Settings.EnableTeamColors and __index(Player, TeamCheckOption) == __index(LocalPlayerESP, TeamCheckOption) and Settings.TeamColor or DefaultColor
        end,
        Calculate3DQuad = function(_CFrame, SizeVector, YVector)
            YVector = YVector or SizeVector
            return {
                {
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, -YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, -YVector.Y, SizeVector.Z).Position)
                },
                {
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, YVector.Y, -SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, YVector.Y, -SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, -YVector.Y, -SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, -YVector.Y, -SizeVector.Z).Position)
                },
                {
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, YVector.Y, -SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, YVector.Y, -SizeVector.Z).Position)
                },
                {
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, -YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, -YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, -YVector.Y, -SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, -YVector.Y, -SizeVector.Z).Position)
                },
                {
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, YVector.Y, -SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, -YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(SizeVector.X, -YVector.Y, -SizeVector.Z).Position)
                },
                {
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, YVector.Y, -SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, -YVector.Y, SizeVector.Z).Position),
                    WorldToViewportPoint(_CFrame * CFramenew(-SizeVector.X, -YVector.Y, -SizeVector.Z).Position)
                }
            }
        end
    }

    local UpdatingFunctions = {
        ESP = function(Entry, TopTextObject, BottomTextObject)
            local Settings = Environment.Properties.ESP
            local Position, Size, OnScreen = CoreFunctions.CalculateParameters(Entry)
            setrenderproperty(TopTextObject, "Visible", OnScreen)
            setrenderproperty(BottomTextObject, "Visible", OnScreen)
            if getrenderproperty(TopTextObject, "Visible") then
                for Index, Value in next, Settings do
                    if stringfind(Index, "Color") or stringfind(Index, "Display") then
                        continue
                    end
                    if not pcall(getrenderproperty, TopTextObject, Index) then
                        continue
                    end
                    setrenderproperty(TopTextObject, Index, Value)
                    setrenderproperty(BottomTextObject, Index, Value)
                end
                local GetColor = CoreFunctions.GetColor
                setrenderproperty(TopTextObject, "Color", GetColor(Entry.Object, Settings.RainbowColor and CoreFunctions.GetRainbowColor() or Settings.Color))
                setrenderproperty(TopTextObject, "OutlineColor", Settings.RainbowOutlineColor and CoreFunctions.GetRainbowColor() or Settings.OutlineColor)
                setrenderproperty(BottomTextObject, "Color", GetColor(Entry.Object, Settings.RainbowColor and CoreFunctions.GetRainbowColor() or Settings.Color))
                setrenderproperty(BottomTextObject, "OutlineColor", Settings.RainbowOutlineColor and CoreFunctions.GetRainbowColor() or Settings.OutlineColor)
                local Offset = mathclamp(Settings.Offset, 10, 30)
                local PositionX, PositionY = Position.X, Position.Y
                local SizeX, SizeY = Size.X, Size.Y
                setrenderproperty(TopTextObject, "Position", Vector2new(PositionX + (SizeX / 2), PositionY - Offset * 2))
                setrenderproperty(BottomTextObject, "Position", Vector2new(PositionX + (SizeX / 2), PositionY + SizeY + Offset / 2))
                local Content, Player, IsAPlayer = "", Entry.Object, Entry.IsAPlayer
                local Name, DisplayName = Entry.Name, Entry.DisplayName
                local Character = IsAPlayer and __index(Player, "Character") or Player
                local Humanoid = FindFirstChildOfClass(Character, "Humanoid")
                local Health, MaxHealth = Humanoid and __index(Humanoid, "Health") or Nan, Humanoid and __index(Humanoid, "MaxHealth") or Nan
                local Tool = Settings.DisplayTool and FindFirstChildOfClass(Character, "Tool")
                Content = ((Settings.DisplayDisplayName and Settings.DisplayName and DisplayName ~= Name) and stringformat("%s (%s)", DisplayName, Name) or (Settings.DisplayDisplayName and not Settings.DisplayName) and DisplayName or (not Settings.DisplayDisplayName and Settings.DisplayName) and Name or (Settings.DisplayName and Settings.DisplayDisplayName and DisplayName == Name) and Name) or Content
                Content = Settings.DisplayHealth and IsAPlayer and stringformat("[%s / %s] ", mathfloor(Health), MaxHealth)..Content or Content
                setrenderproperty(TopTextObject, "Text", Content)
                local PlayerPosition = __index((IsAPlayer and (__index(Character, "PrimaryPart") or __index(Character, "Head")) or Character), "Position") or Vector3zero
                local Distance = Settings.DisplayDistance and mathfloor((PlayerPosition - CoreFunctions.GetLocalCharacterPosition()).Magnitude)
                Content = Distance and stringformat("%s Studs", Distance) or ""
                setrenderproperty(BottomTextObject, "Text", Content..(Tool and ((Distance and "\n" or "")..__index(Tool, "Name")) or ""))
            end
        end,
        Box = function(Entry, BoxObject, BoxOutlineObject)
            local Settings = Environment.Properties.Box
            local Position, Size, OnScreen = CoreFunctions.CalculateParameters(Entry)
            setrenderproperty(BoxObject, "Visible", OnScreen)
            setrenderproperty(BoxOutlineObject, "Visible", OnScreen and Settings.Outline)
            if getrenderproperty(BoxObject, "Visible") then
                setrenderproperty(BoxObject, "Position", Position)
                setrenderproperty(BoxObject, "Size", Size)
                for Index, Value in next, Settings do
                    if Index == "Color" then
                        continue
                    end
                    if not pcall(getrenderproperty, BoxObject, Index) then
                        continue
                    end
                    setrenderproperty(BoxObject, Index, Value)
                end
                setrenderproperty(BoxObject, "Color", CoreFunctions.GetColor(Entry.Object, Settings.RainbowColor and CoreFunctions.GetRainbowColor() or Settings.Color))
                if Settings.Outline then
                    setrenderproperty(BoxOutlineObject, "Position", Position)
                    setrenderproperty(BoxOutlineObject, "Size", Size)
                    setrenderproperty(BoxOutlineObject, "Color", Settings.RainbowOutlineColor and CoreFunctions.GetRainbowColor() or Settings.OutlineColor)
                    setrenderproperty(BoxOutlineObject, "Thickness", Settings.Thickness + 1)
                    setrenderproperty(BoxOutlineObject, "Transparency", Settings.Transparency)
                end
            end
        end,
        HealthBar = function(Entry, MainObject, OutlineObject, Humanoid)
            local Settings = Environment.Properties.HealthBar
            local Position, Size, OnScreen = CoreFunctions.CalculateParameters(Entry)
            setrenderproperty(MainObject, "Visible", OnScreen)
            setrenderproperty(OutlineObject, "Visible", OnScreen and Settings.Outline)
            if getrenderproperty(MainObject, "Visible") then
                for Index, Value in next, Settings do
                    if Index == "Color" then
                        continue
                    end
                    if not pcall(getrenderproperty, MainObject, Index) then
                        continue
                    end
                    setrenderproperty(MainObject, Index, Value)
                end
                Humanoid = Humanoid or FindFirstChildOfClass(__index(Entry.Object, "Character"), "Humanoid")
                local MaxHealth = Humanoid and __index(Humanoid, "MaxHealth") or 100
                local Health = Humanoid and mathclamp(__index(Humanoid, "Health"), 0, MaxHealth) or 0
                local Offset = mathclamp(Settings.Offset, 4, 12)
                setrenderproperty(MainObject, "Color", CoreFunctions.GetColorFromHealth(Health, MaxHealth, Settings.Blue))
                if Settings.Position == 1 then
                    setrenderproperty(MainObject, "From", Vector2new(Position.X, Position.Y - Offset))
                    setrenderproperty(MainObject, "To", Vector2new(Position.X + (Health / MaxHealth) * Size.X, Position.Y - Offset))
                    if Settings.Outline then
                        setrenderproperty(OutlineObject, "From", Vector2new(Position.X - 1, Position.Y - Offset))
                        setrenderproperty(OutlineObject, "To", Vector2new(Position.X + Size.X + 1, Position.Y - Offset))
                    end
                elseif Settings.Position == 2 then
                    setrenderproperty(MainObject, "From", Vector2new(Position.X, Position.Y + Size.Y + Offset))
                    setrenderproperty(MainObject, "To", Vector2new(Position.X + (Health / MaxHealth) * Size.X, Position.Y + Size.Y + Offset))
                    if Settings.Outline then
                        setrenderproperty(OutlineObject, "From", Vector2new(Position.X - 1, Position.Y + Size.Y + Offset))
                        setrenderproperty(OutlineObject, "To", Vector2new(Position.X + Size.X + 1, Position.Y + Size.Y + Offset))
                    end
                elseif Settings.Position == 3 then
                    setrenderproperty(MainObject, "From", Vector2new(Position.X - Offset, Position.Y + Size.Y))
                    setrenderproperty(MainObject, "To", Vector2new(Position.X - Offset, getrenderproperty(MainObject, "From").Y - (Health / MaxHealth) * Size.Y))
                    if Settings.Outline then
                        setrenderproperty(OutlineObject, "From", Vector2new(Position.X - Offset, Position.Y + Size.Y + 1))
                        setrenderproperty(OutlineObject, "To", Vector2new(Position.X - Offset, (getrenderproperty(OutlineObject, "From").Y - 1 * Size.Y) - 2))
                    end
                elseif Settings.Position == 4 then
                    setrenderproperty(MainObject, "From", Vector2new(Position.X + Size.X + Offset, Position.Y + Size.Y))
                    setrenderproperty(MainObject, "To", Vector2new(Position.X + Size.X + Offset, getrenderproperty(MainObject, "From").Y - (Health / MaxHealth) * Size.Y))
                    if Settings.Outline then
                        setrenderproperty(OutlineObject, "From", Vector2new(Position.X + Size.X + Offset, Position.Y + Size.Y + 1))
                        setrenderproperty(OutlineObject, "To", Vector2new(Position.X + Size.X + Offset, (getrenderproperty(OutlineObject, "From").Y - 1 * Size.Y) - 2))
                    end
                else
                    Settings.Position = 3
                end
                if Settings.Outline then
                    setrenderproperty(OutlineObject, "Color", Settings.RainbowOutlineColor and CoreFunctions.GetRainbowColor() or Settings.OutlineColor)
                    setrenderproperty(OutlineObject, "Thickness", Settings.Thickness + 1)
                    setrenderproperty(OutlineObject, "Transparency", Settings.Transparency)
                end
            end
        end
    }

    local CreatingFunctions = {
        ESP = function(Entry)
            local Allowed = Entry.Allowed
            if type(Allowed) == "table" and type(Allowed.ESP) == "boolean" and not Allowed.ESP then
                return
            end
            local Settings = Environment.Properties.ESP
            local TopText = Drawingnew("Text")
            local TopTextObject = TopText
            setrenderproperty(TopTextObject, "Center", true)
            local BottomText = Drawingnew("Text")
            local BottomTextObject = BottomText
            setrenderproperty(BottomTextObject, "Center", true)
            Entry.Visuals.ESP[1] = TopText
            Entry.Visuals.ESP[2] = BottomText
            Entry.Connections.ESP = Connect(__index(RunServiceESP, Environment.DeveloperSettings.UpdateMode), function()
                local Functionable, Ready = pcall(function()
                    return Environment.Settings.Enabled and Settings.Enabled and Entry.Checks.Ready
                end)
                if not Functionable then
                    pcall(TopText.Remove, TopText)
                    pcall(BottomText.Remove, BottomText)
                    return Disconnect(Entry.Connections.ESP)
                end
                if Ready then
                    UpdatingFunctions.ESP(Entry, TopTextObject, BottomTextObject)
                else
                    setrenderproperty(TopTextObject, "Visible", false)
                    setrenderproperty(BottomTextObject, "Visible", false)
                end
            end)
        end,
        Box = function(Entry)
            local Allowed = Entry.Allowed
            if type(Allowed) == "table" and type(Allowed.Box) == "boolean" and not Allowed.Box then
                return
            end
            local Settings = Environment.Properties.Box
            local BoxOutline = Drawingnew("Square")
            local BoxOutlineObject = BoxOutline
            local Box = Drawingnew("Square")
            local BoxObject = Box
            Entry.Visuals.Box[1] = Box
            Entry.Visuals.Box[2] = BoxOutline
            Entry.Connections.Box = Connect(__index(RunServiceESP, Environment.DeveloperSettings.UpdateMode), function()
                local Functionable, Ready = pcall(function()
                    return Environment.Settings.Enabled and Settings.Enabled and Entry.Checks.Ready
                end)
                if not Functionable then
                    pcall(Box.Remove, Box)
                    pcall(BoxOutline.Remove, BoxOutline)
                    return Disconnect(Entry.Connections.Box)
                end
                if Ready then
                    UpdatingFunctions.Box(Entry, BoxObject, BoxOutlineObject)
                else
                    setrenderproperty(BoxObject, "Visible", false)
                    setrenderproperty(BoxOutlineObject, "Visible", false)
                end
            end)
        end,
        HealthBar = function(Entry)
            local Allowed = Entry.Allowed
            if type(Allowed) == "table" and type(Allowed.HealthBar) == "boolean" and not Allowed.HealthBar then
                return
            end
            local Humanoid = FindFirstChildOfClass(__index(Entry.Object, "Parent"), "Humanoid")
            if not Entry.IsAPlayer and not Humanoid then
                return
            end
            local Settings = Environment.Properties.HealthBar
            local Outline = Drawingnew("Line")
            local OutlineObject = Outline
            local Main = Drawingnew("Line")
            local MainObject = Main
            Entry.Visuals.HealthBar[1] = Main
            Entry.Visuals.HealthBar[2] = Outline
            Entry.Connections.HealthBar = Connect(__index(RunServiceESP, Environment.DeveloperSettings.UpdateMode), function()
                local Functionable, Ready = pcall(function()
                    return Environment.Settings.Enabled and Settings.Enabled and Entry.Checks.Ready
                end)
                if not Functionable then
                    pcall(Main.Remove, Main)
                    pcall(Outline.Remove, Outline)
                    return Disconnect(Entry.Connections.HealthBar)
                end
                if Ready then
                    UpdatingFunctions.HealthBar(Entry, MainObject, OutlineObject, Humanoid)
                else
                    setrenderproperty(MainObject, "Visible", false)
                    setrenderproperty(OutlineObject, "Visible", false)
                end
            end)
        end
    }

    local UtilityFunctions = {
        InitChecks = function(self, Entry)
            if not Entry.IsAPlayer and not Entry.PartHasCharacter and not Entry.RenderDistance then
                return
            end
            local Player = Entry.Object
            local Checks = Entry.Checks
            local Hash = Entry.Hash
            local IsAPlayer = Entry.IsAPlayer
            local PartHasCharacter = Entry.PartHasCharacter
            local Settings = Environment.Settings
            local DeveloperSettings = Environment.DeveloperSettings
            local LocalCharacterPosition = CoreFunctions.GetLocalCharacterPosition()
            Entry.Connections.UpdateChecks = Connect(__index(RunServiceESP, DeveloperSettings.UpdateMode), function()
                local RenderDistance = Entry.RenderDistance
                if not IsAPlayer and not PartHasCharacter then
                    Checks.Ready = (__index(Player, "Position") - LocalCharacterPosition).Magnitude <= RenderDistance; return
                end
                if not IsAPlayer then
                    local PartHumanoid = FindFirstChildOfClass(__index(Player, "Parent"), "Humanoid")
                    Checks.Ready = PartHasCharacter and PartHumanoid and IsDescendantOf(Player, WorkspaceESP)
                    if not Checks.Ready then
                        return self.UnwrapObject(Hash)
                    end
                    local IsInDistance = (__index(Player, "Position") - CoreFunctions.GetLocalCharacterPosition()).Magnitude <= RenderDistance
                    if Settings.AliveCheck then
                        Checks.Alive = __index(PartHumanoid, "Health") > 0
                    end
                    Checks.Ready = Checks.Ready and Checks.Alive and IsInDistance and Environment.Settings.EntityESP
                    return
                end
                local Character = __index(Player, "Character")
                local Humanoid = Character and FindFirstChildOfClass(Character, "Humanoid")
                local Head = Character and FindFirstChild(Character, "Head")
                local IsInDistance
                if Character and IsDescendantOf(Character, WorkspaceESP) and Humanoid and Head then
                    local TeamCheckOption = DeveloperSettings.TeamCheckOption
                    Checks.Alive = true
                    Checks.Team = true
                    if Settings.AliveCheck then
                        Checks.Alive = __index(Humanoid, "Health") > 0
                    end
                    if Settings.TeamCheck then
                        Checks.Team = __index(Player, TeamCheckOption) ~= __index(LocalPlayerESP, TeamCheckOption)
                    end
                    IsInDistance = (__index(Head, "Position") - LocalCharacterPosition).Magnitude <= RenderDistance
                else
                    Checks.Alive = false
                    Checks.Team = false
                    if DeveloperSettings.UnwrapOnCharacterAbsence then
                        self.UnwrapObject(Hash)
                    end
                end
                Checks.Ready = Checks.Alive and Checks.Team and not Settings.PartsOnly and IsInDistance
                if Checks.Ready then
                    local Part = IsAPlayer and (FindFirstChild(PlayersESP, __index(Player, "Name")) and __index(Player, "Character"))
                    Part = IsAPlayer and (Part and (__index(Part, "PrimaryPart") or FindFirstChild(Part, "HumanoidRootPart"))) or Player
                    Entry.RigType = Humanoid and FindFirstChild(__index(Part, "Parent"), "Torso") and "R6" or "R15"
                    Entry.RigType = Entry.RigType == "N/A" and Humanoid and (__index(Humanoid, "RigType") == 0 and "R6" or "R15") or "N/A"
                    Entry.RigType = Entry.RigType == "N/A" and Humanoid and (__index(Humanoid, "RigType") == Enum.HumanoidRigType.R6 and "R6" or "R15") or "N/A"
                end
            end)
        end,
        GetObjectEntry = function(Object, Hash)
            Hash = type(Object) == "string" and Object or Hash
            for _, Value in next, Environment.UtilityAssets.WrappedObjects do
                if Hash and Value.Hash == Hash or Value.Object == Object then
                    return Value
                end
            end
        end,
        WrapObject = function(self, Object, PseudoName, Allowed, RenderDistance)
            assert(self, "EXUNYS_ESP > UtilityFunctions.WrapObject - Internal error, unassigned parameter \"self\".")
            if pcall(gethiddenproperty, Object, "PrimaryPart") then
                Object = __index(Object, "PrimaryPart")
            end
            if not Object then
                return
            end
            local DeveloperSettings = Environment.DeveloperSettings
            local WrappedObjects = Environment.UtilityAssets.WrappedObjects
            for _, Value in next, WrappedObjects do
                if Value.Object == Object then
                    return
                end
            end
            local Entry = {
                Hash = CoreFunctions.GenerateHash(0x100),
                Object = Object,
                Allowed = Allowed,
                Name = PseudoName or __index(Object, "Name"),
                DisplayName = PseudoName or __index(Object, (IsA(Object, "Player") and "Display" or "").."Name"),
                RenderDistance = RenderDistance or Inf,
                IsAPlayer = IsA(Object, "Player"),
                PartHasCharacter = false,
                RigType = "N/A",
                Checks = {
                    Alive = true,
                    Team = true,
                    Ready = true
                },
                Visuals = {
                    ESP = {},
                    Tracer = {},
                    Box = {},
                    HealthBar = {},
                    HeadDot = {},
                    Chams = {}
                },
                Connections = {}
            }
            repeat wait(0) until Entry.IsAPlayer and FindFirstChildOfClass(__index(Entry.Object, "Character"), "Humanoid") or true
            if not Entry.IsAPlayer then
                if not pcall(function()
                    return __index(Entry.Object, "Position"), __index(Entry.Object, "CFrame")
                end) then
                    warn("EXUNYS_ESP > UtilityFunctions.WrapObject - Attempted to wrap object of an unsupported class type: \""..(__index(Entry.Object, "ClassName") or "N / A").."\"")
                    return self.UnwrapObject(Entry.Hash)
                end
                Entry.Connections.UnwrapSignal = Connect(Entry.Object.Changed, function(Property)
                    if Property == "Parent" and not IsDescendantOf(__index(Entry.Object, Property), WorkspaceESP) then
                        self.UnwrapObject(nil, Entry.Hash)
                    end
                end)
            end
            local Humanoid = Entry.IsAPlayer and FindFirstChildOfClass(__index(Entry.Object, "Character"), "Humanoid") or FindFirstChildOfClass(__index(Entry.Object, "Parent"), "Humanoid")
            Entry.PartHasCharacter = not Entry.IsAPlayer and Humanoid
            Entry.RigType = Humanoid and (__index(Humanoid, "RigType") == 0 and "R6" or "R15") or "N/A"
            self:InitChecks(Entry)
            spawn(function()
                repeat
                    wait(0)
                until Entry.Checks.Ready
                CreatingFunctions.Box(Entry)
                CreatingFunctions.HealthBar(Entry)
                CreatingFunctions.ESP(Entry)
                WrappedObjects[Entry.Hash] = Entry
                Entry.Connections.PlayerUnwrapSignal = Connect(Entry.Object.Changed, function(Property)
                    if DeveloperSettings.UnwrapOnCharacterAbsence and Property == "Parent" and not IsDescendantOf(__index(Entry.Object, (Entry.IsAPlayer and "Character" or Property)), WorkspaceESP) then
                        self.UnwrapObject(nil, Entry.Hash)
                    end
                end)
                return Entry.Hash
            end)
        end,
        UnwrapObject = function(Object, Hash)
            Hash = type(Object) == "string" and Object
            Object = type(Object) == "string" and nil
            for _, Value in next, Environment.UtilityAssets.WrappedObjects do
                if Value.Object == Object or Value.Hash == Hash then
                    for _, _Value in next, Value.Connections do
                        pcall(Disconnect, _Value)
                    end
                    Recursive(Value.Visuals, function(_, _Value)
                        if type(_Value) == "table" and _Value then
                            pcall(_Value.Remove, _Value)
                        end
                    end)
                    Environment.UtilityAssets.WrappedObjects[Hash] = nil; break
                end
            end
        end
    }

    local LoadESP = function()
        for _, Value in next, GetPlayers() do
            if Value == LocalPlayerESP then
                continue
            end
            UtilityFunctions:WrapObject(Value)
        end
        local ServiceConnections = Environment.UtilityAssets.ServiceConnections
        ServiceConnections.PlayerRemoving = Connect(__index(PlayersESP, "PlayerRemoving"), UtilityFunctions.UnwrapObject)
        ServiceConnections.CharacterAdded = Connect(__index(WorkspaceESP, "DescendantAdded"), function(Object)
            if not IsA(Object, "Model") then
                return
            end
            if not GetPlayerFromCharacter(Object) or not FindFirstChild(PlayersESP, __index(Object, "Name")) then
                return
            end
            for _, Value in next, GetPlayers() do
                local Player = nil
                for _, _Value in next, Environment.UtilityAssets.WrappedObjects do
                    if not _Value.IsAPlayer then
                        continue
                    end
                    if __index(_Value.Object, "Name") == __index(Value, "Name") then
                        Player = _Value
                    end
                end
                if not Player then
                    UtilityFunctions:WrapObject(GetPlayerFromCharacter(Object))
                end
            end
        end)
        ServiceConnections.PlayerAdded = Connect(__index(PlayersESP, "PlayerAdded"), function(Player)
            local WrappedObjects = Environment.UtilityAssets.WrappedObjects
            local Hash = UtilityFunctions:WrapObject(Player)
            for _, Entry in next, WrappedObjects do
                if Entry.Hash ~= Hash then
                    continue
                end
                Entry.Connections[__index(Player, "Name").."CharacterAdded"] = Connect(__index(Player, "CharacterAdded"), function(Object)
                    for _, _Value in next, Environment.UtilityAssets.WrappedObjects do
                        if not _Value.Name == __index(Object, "Name") then
                            continue
                        end
                        UtilityFunctions:WrapObject(GetPlayerFromCharacter(Object))
                    end
                end)
            end
        end)
    end

    Environment.UnwrapPlayers = function()
        local UtilityAssets = Environment.UtilityAssets
        local WrappedObjects = UtilityAssets.WrappedObjects
        local ServiceConnections = UtilityAssets.ServiceConnections
        for _, Entry in next, WrappedObjects do
            pcall(UtilityFunctions.UnwrapObject, Entry.Hash)
        end
        for _, ConnectionIndex in next, {"PlayerRemoving", "PlayerAdded", "CharacterAdded"} do
            pcall(Disconnect, ServiceConnections[ConnectionIndex])
        end
        return #WrappedObjects == 0
    end

    Environment.UnwrapAll = function(self)
        assert(self, "EXUNYS_ESP.UnwrapAll: Missing parameter #1 \"self\" <table>.")
        if self.UnwrapPlayers() and CrosshairParts.LeftLine then
            self.RemoveCrosshair()
        end
        return #self.UtilityAssets.WrappedObjects == 0 and not CrosshairParts.LeftLine
    end

    Environment.Exit = function(self)
        assert(self, "EXUNYS_ESP.Exit: Missing parameter #1 \"self\" <table>.")
        if self:UnwrapAll() then
            for _, Connection in next, self.UtilityAssets.ServiceConnections do
                pcall(Disconnect, Connection)
            end
            for _, RenderObject in next, CrosshairParts do
                pcall(RenderObject.Remove, RenderObject)
            end
            for _, Table in next, {CoreFunctions, UpdatingFunctions, CreatingFunctions, UtilityFunctions} do
                for FunctionName, _ in next, Table do
                    Table[FunctionName] = nil
                end
                Table = nil
            end
            for Index, _ in next, Environment do
                getgenv().ExunysDeveloperESP[Index] = nil
            end
            LoadESP = nil; Recursive = nil; LoadedESP = false
            if cleardrawcache then
                cleardrawcache()
            end
            getgenv().ExunysDeveloperESP = nil
        end
    end

    Environment.WrapObject = function(...)
        return UtilityFunctions:WrapObject(...)
    end

    Environment.UnwrapObject = UtilityFunctions.UnwrapObject

    Environment.RemoveCrosshair = function()
        if not CrosshairParts.LeftLine then
            return
        end
        local ServiceConnections = Environment.UtilityAssets.ServiceConnections
        Disconnect(ServiceConnections.UpdateCrosshairProperties)
        Disconnect(ServiceConnections.UpdateCrosshair)
        for _, RenderObject in next, CrosshairParts do
            pcall(RenderObject.Remove, RenderObject)
        end
        CrosshairParts = {}
    end

    Environment.WrapPlayers = LoadESP

    Environment.GetEntry = UtilityFunctions.GetObjectEntry

    Environment.Load = function()
        if LoadedESP then
            return
        end
        LoadESP(); LoadedESP = true
    end

    ESPModule = Environment
end

-- ESP Variables
local ESPEnabled = false
local ESPColor = Color3.fromRGB(255, 0, 0)

--[[
    MAIN TAB FEATURES
]]

local MainSection = Tabs.Main:AddLeftGroupbox('Movement Features')

-- Teleport Walk
local TeleportWalkEnabled = false
local TeleportWalkSpeed = 50
local TeleportWalkConnection = nil

local TeleportWalkToggle = MainSection:AddToggle('TeleportWalk', {
    Text = 'Teleport Walk',
    Default = false,
    Tooltip = 'Teleport walk with adjustable speed',
})

TeleportWalkToggle:OnChanged(function(Value)
    TeleportWalkEnabled = Value
    if TeleportWalkConnection then
        TeleportWalkConnection:Disconnect()
        TeleportWalkConnection = nil
    end
    
    if Value then
        TeleportWalkConnection = RunService.Heartbeat:Connect(function()
            if not TeleportWalkEnabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
            
            local Humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if not Humanoid then return end
            
            local MoveDirection = Humanoid.MoveDirection
            if MoveDirection.Magnitude > 0 then
                LocalPlayer.Character:SetPrimaryPartCFrame(
                    LocalPlayer.Character.HumanoidRootPart.CFrame + (MoveDirection * TeleportWalkSpeed * 0.1)
                )
            end
        end)
        Library:Notify('Teleport Walk enabled!', 2)
    else
        Library:Notify('Teleport Walk disabled!', 2)
    end
end)

local TeleportWalkSpeedSlider = MainSection:AddSlider('TeleportWalkSpeed', {
    Text = 'Teleport Walk Speed',
    Default = 50,
    Min = 10,
    Max = 200,
    Rounding = 0,
})

TeleportWalkSpeedSlider:OnChanged(function(Value)
    TeleportWalkSpeed = Value
end)

MainSection:AddDivider()

-- Infinite Jump
local InfiniteJumpEnabled = false
local InfiniteJumpConnection = nil

local InfiniteJumpToggle = MainSection:AddToggle('InfiniteJump', {
    Text = 'Infinite Jump',
    Default = false,
    Tooltip = 'Jump infinitely without touching ground',
})

InfiniteJumpToggle:OnChanged(function(Value)
    InfiniteJumpEnabled = Value
    if InfiniteJumpConnection then
        InfiniteJumpConnection:Disconnect()
        InfiniteJumpConnection = nil
    end
    
    if Value then
        InfiniteJumpConnection = UserInputService.JumpRequest:Connect(function()
            if InfiniteJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end)
        Library:Notify('Infinite Jump enabled!', 2)
    else
        Library:Notify('Infinite Jump disabled!', 2)
    end
end)

MainSection:AddDivider()

-- Noclip
local NoclipEnabled = false
local NoclipConnection = nil

local NoclipToggle = MainSection:AddToggle('Noclip', {
    Text = 'Noclip',
    Default = false,
    Tooltip = 'Walk through walls',
})

NoclipToggle:OnChanged(function(Value)
    NoclipEnabled = Value
    if NoclipConnection then
        NoclipConnection:Disconnect()
        NoclipConnection = nil
    end
    
    if Value then
        NoclipConnection = RunService.Stepped:Connect(function()
            if not NoclipEnabled or not LocalPlayer.Character then return end
            
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end)
        Library:Notify('Noclip enabled!', 2)
    else
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
        Library:Notify('Noclip disabled!', 2)
    end
end)

MainSection:AddDivider()

-- Antivoid
local AntivoidEnabled = false
local OriginalFallenPartsDestroyHeight = Workspace.FallenPartsDestroyHeight

local AntivoidToggle = MainSection:AddToggle('Antivoid', {
    Text = 'Antivoid',
    Default = false,
    Tooltip = 'Prevent falling into void',
})

AntivoidToggle:OnChanged(function(Value)
    AntivoidEnabled = Value
    if Value then
        Workspace.FallenPartsDestroyHeight = 0/0 -- NaN (on)
        Library:Notify('Antivoid enabled!', 2)
    else
        Workspace.FallenPartsDestroyHeight = -500 -- Off
        Library:Notify('Antivoid disabled!', 2)
    end
end)

MainSection:AddDivider()

-- Player List with Teleport and Orbit
local PlayerListSection = Tabs.Main:AddRightGroupbox('Player List')

local SelectedPlayer = nil
local Orbiting = false
local OrbitSpeed = 10
local OrbitDistance = 5
local OrbitConnection = nil

-- Function to get player list
local function GetPlayerList()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

local PlayerDropdown = PlayerListSection:AddDropdown('PlayerList', {
    Values = GetPlayerList(),
    Default = 1,
    Multi = false,
    Text = 'Select Player',
})

PlayerDropdown:OnChanged(function(Value)
    SelectedPlayer = Players:FindFirstChild(Value)
    if SelectedPlayer then
        Library:Notify('Selected: ' .. Value, 2)
    end
end)

PlayerListSection:AddButton('Refresh Player List', function()
    PlayerDropdown:SetValues(GetPlayerList())
    Library:Notify('Player list refreshed!', 2)
end)

PlayerListSection:AddButton('Teleport to Player', function()
    if SelectedPlayer and SelectedPlayer.Character and SelectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character:SetPrimaryPartCFrame(SelectedPlayer.Character.HumanoidRootPart.CFrame)
            Library:Notify('Teleported to ' .. SelectedPlayer.Name, 2)
        end
    else
        Library:Notify('Player not found or no character!', 2)
    end
end)

local OrbitToggle = PlayerListSection:AddToggle('OrbitPlayer', {
    Text = 'Orbit Player',
    Default = false,
    Tooltip = 'Orbit around selected player',
})

OrbitToggle:OnChanged(function(Value)
    Orbiting = Value
    if OrbitConnection then
        OrbitConnection:Disconnect()
        OrbitConnection = nil
    end
    
    if Value and SelectedPlayer then
        OrbitConnection = RunService.Heartbeat:Connect(function()
            if not Orbiting or not SelectedPlayer or not SelectedPlayer.Character or not SelectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                if OrbitConnection then
                    OrbitConnection:Disconnect()
                    OrbitConnection = nil
                end
                return
            end
            
            if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
            
            local targetPosition = SelectedPlayer.Character.HumanoidRootPart.Position
            local currentPosition = LocalPlayer.Character.HumanoidRootPart.Position
            local direction = (currentPosition - targetPosition)
            local distance = direction.Magnitude
            
            local angle = tick() * OrbitSpeed
            local offset = Vector3.new(
                math.cos(angle) * OrbitDistance,
                2, -- Height offset
                math.sin(angle) * OrbitDistance
            )
            LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(targetPosition + offset, targetPosition))
        end)
        Library:Notify('Orbiting ' .. SelectedPlayer.Name, 2)
    else
        Library:Notify('Orbit disabled!', 2)
    end
end)

local OrbitSpeedSlider = PlayerListSection:AddSlider('OrbitSpeed', {
    Text = 'Orbit Speed',
    Default = 10,
    Min = 1,
    Max = 50,
    Rounding = 0,
})

OrbitSpeedSlider:OnChanged(function(Value)
    OrbitSpeed = Value
end)

local OrbitDistanceSlider = PlayerListSection:AddSlider('OrbitDistance', {
    Text = 'Orbit Distance',
    Default = 5,
    Min = 1,
    Max = 20,
    Rounding = 0,
})

OrbitDistanceSlider:OnChanged(function(Value)
    OrbitDistance = Value
end)

MainSection:AddDivider()

-- Desync Button
MainSection:AddButton('Desync', function()
    Library:Notify('Applying desync...', 3)
    
    -- Desync Script
    pcall(function()
        setfflag("NextGenReplicatorEnabledWrite4", "true")
    end)
    
    wait(1)
    
    local jobId = game.JobId
    
    if jobId and jobId ~= "" then
        TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, LocalPlayer)
    else
        warn("No JobId found, rejoining normally...")
        TeleportService:Teleport(game.PlaceId, LocalPlayer)
    end
end)

-- Update player list when players join/leave
Players.PlayerAdded:Connect(function()
    wait(0.5)
    PlayerDropdown:SetValues(GetPlayerList())
end)

Players.PlayerRemoving:Connect(function()
    wait(0.5)
    PlayerDropdown:SetValues(GetPlayerList())
end)

--[[
    ESP TAB
]]

local ESPSection = Tabs.ESP:AddLeftGroupbox('ESP Settings')

local ESPBoxesToggle = ESPSection:AddToggle('ESPBoxes', {
    Text = 'Show Boxes',
    Default = true,
})

local ESPHealthToggle = ESPSection:AddToggle('ESPHealth', {
    Text = 'Show Health',
    Default = true,
})

local ESPNamesToggle = ESPSection:AddToggle('ESPNames', {
    Text = 'Show Names',
    Default = true,
})

-- Color picker - try different method names
local ESPColorPicker = nil
local function UpdateESPColor(color)
    ESPColor = color
    if ESPModule then
        ESPModule.Properties.Box.Color = color
        ESPModule.Properties.HealthBar.Color = color
        ESPModule.Properties.ESP.Color = color
    end
end

-- Try AddColorpicker (lowercase p)
local success, result = pcall(function()
    return ESPSection:AddColorpicker('ESPColor', {
        Text = 'ESP Color',
        Default = Color3.fromRGB(255, 0, 0),
        Callback = UpdateESPColor
    })
end)

if success then
    ESPColorPicker = result
else
    -- Try AddColorPicker (capital P)
    success, result = pcall(function()
        return ESPSection:AddColorPicker('ESPColor', {
            Text = 'ESP Color',
            Default = Color3.fromRGB(255, 0, 0),
            Callback = UpdateESPColor
        })
    end)
    if success then
        ESPColorPicker = result
    else
        -- Fallback: Use RGB sliders
        ESPSection:AddLabel('ESP Color (RGB Sliders)')
        local ESPR = ESPSection:AddSlider('ESPR', {
            Text = 'Red',
            Default = 255,
            Min = 0,
            Max = 255,
            Rounding = 0,
            Callback = function(Value)
                local g = ESPColor and math.floor(ESPColor.G * 255) or 0
                local b = ESPColor and math.floor(ESPColor.B * 255) or 0
                UpdateESPColor(Color3.fromRGB(Value, g, b))
            end
        })
        local ESPG = ESPSection:AddSlider('ESPG', {
            Text = 'Green',
            Default = 0,
            Min = 0,
            Max = 255,
            Rounding = 0,
            Callback = function(Value)
                local r = ESPColor and math.floor(ESPColor.R * 255) or 255
                local b = ESPColor and math.floor(ESPColor.B * 255) or 0
                UpdateESPColor(Color3.fromRGB(r, Value, b))
            end
        })
        local ESPB = ESPSection:AddSlider('ESPB', {
            Text = 'Blue',
            Default = 0,
            Min = 0,
            Max = 255,
            Rounding = 0,
            Callback = function(Value)
                local r = ESPColor and math.floor(ESPColor.R * 255) or 255
                local g = ESPColor and math.floor(ESPColor.G * 255) or 0
                UpdateESPColor(Color3.fromRGB(r, g, Value))
            end
        })
    end
end

local ESPMainToggle = ESPSection:AddToggle('ESPEnabled', {
    Text = 'Enable ESP',
    Default = false,
    Callback = function(Value)
        ESPEnabled = Value
        if ESPModule then
            if Value then
                ESPModule.Settings.Enabled = true
                ESPModule:Load()
                Library:Notify('ESP enabled!', 2)
            else
                ESPModule.Settings.Enabled = false
                ESPModule:UnwrapAll()
                Library:Notify('ESP disabled!', 2)
            end
        else
            Library:Notify('ESP Module not loaded!', 3)
        end
    end
})

ESPBoxesToggle:OnChanged(function(Value)
    if ESPModule then
        ESPModule.Properties.Box.Enabled = Value
    end
end)

ESPHealthToggle:OnChanged(function(Value)
    if ESPModule then
        ESPModule.Properties.HealthBar.Enabled = Value
    end
end)

ESPNamesToggle:OnChanged(function(Value)
    if ESPModule then
        ESPModule.Properties.ESP.DisplayName = Value
        ESPModule.Properties.ESP.DisplayDisplayName = Value
    end
end)

--[[
    SETTINGS TAB
]]

-- Add a groupbox to ensure the tab is visible
local SettingsSection = Tabs.Settings:AddLeftGroupbox('Settings')

-- Theme Manager
ThemeManager:SetLibrary(Library)
ThemeManager:SetFolder('RobloxScriptHub')
ThemeManager:ApplyToTab(Tabs.Settings)

-- Save Manager
SaveManager:SetLibrary(Library)
SaveManager:SetFolder('RobloxScriptHub/configs')
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
SaveManager:BuildConfigSection(Tabs.Settings)

-- Auto-save configuration
SaveManager:LoadAutoloadConfig()

-- Initialize the UI
Library:Notify('Script loaded successfully!', 3)
